"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useSnackbar } from "notistack";
import { useGameState } from "@/hooks/useGameState";
import { capitalize, getLevelName, DIGIMON_TYPE_NAMES } from "@/lib/utils";
import { getTamerImagePath } from "@/lib/image-utils";
import DigimonDetailsModal from "@/app/components/DigimonDetailsModal";
import AttackDialog from "@/app/components/AttackDialog";
import ReviveDialog from "@/app/components/ReviveDialog";
import { GameDigimon, GameState } from "@/types/game";

export default function GamePage() {
  const router = useRouter();
  const { enqueueSnackbar } = useSnackbar();
  const { gameState, saveGameState, clearGameState, isLoading } =
    useGameState();
  const [showEndGameConfirm, setShowEndGameConfirm] = useState(false);
  const [selectedDigimon, setSelectedDigimon] = useState<{
    digimon: GameDigimon;
    playerName: string;
    playerId: number;
    originalId: number; // ID original para rastreamento ap√≥s evolu√ß√£o
  } | null>(null);
  const [showAttackDialog, setShowAttackDialog] = useState(false);
  const [attackerDigimon, setAttackerDigimon] = useState<{
    digimon: GameDigimon;
    playerName: string;
  } | null>(null);

  // Backup do selectedDigimon para uso durante o ataque
  const [attackContext, setAttackContext] = useState<{
    attacker: GameDigimon;
    attackerPlayerName: string;
    attackerPlayerId: number;
    originalSelectedDigimon: typeof selectedDigimon;
  } | null>(null);
  const [showReviveDialog, setShowReviveDialog] = useState(false);
  const [reviveTarget, setReviveTarget] = useState<{
    digimon: GameDigimon;
    name: string;
    playerId: number;
  } | null>(null);
  const [winner, setWinner] = useState<{
    playerName: string;
    playerImage: string;
    aliveDigimons: GameDigimon[];
  } | null>(null);

  useEffect(() => {
    // Se n√£o h√° estado de jogo e n√£o est√° carregando, redirecionar para home
    if (!isLoading && !gameState) {
      enqueueSnackbar("Nenhum jogo ativo encontrado.", { variant: "info" });
      router.push("/");
    }
  }, [gameState, isLoading, router, enqueueSnackbar]);

  // Verificar condi√ß√£o de vit√≥ria
  useEffect(() => {
    if (!gameState) return;

    const playersWithAliveDigimons = gameState.players.filter((player) =>
      player.digimons.some((digimon) => digimon.currentHp > 0)
    );

    // Se apenas um jogador tem Digimons vivos, declarar vencedor
    if (playersWithAliveDigimons.length === 1) {
      const winnerPlayer = playersWithAliveDigimons[0];
      const aliveDigimons = winnerPlayer.digimons.filter(
        (d) => d.currentHp > 0
      );

      setWinner({
        playerName: winnerPlayer.name,
        playerImage: getTamerImagePath(winnerPlayer.avatar),
        aliveDigimons,
      });
    }
  }, [gameState]);

  const handleEndGame = () => {
    clearGameState();
    enqueueSnackbar("Jogo finalizado!", { variant: "success" });
    router.push("/");
  };

  const handleNextTurn = () => {
    if (!gameState) return;

    const nextPlayerIndex =
      (gameState.currentTurnPlayerIndex + 1) % gameState.players.length;
    const isNewRound = nextPlayerIndex === 0;

    // Resetar hasActedThisTurn do pr√≥ximo jogador
    const updatedState = {
      ...gameState,
      currentTurnPlayerIndex: nextPlayerIndex,
      turnCount: isNewRound ? gameState.turnCount + 1 : gameState.turnCount,
      players: gameState.players.map((player, idx) => {
        if (idx === nextPlayerIndex) {
          // Resetar a√ß√µes dos Digimons do pr√≥ximo jogador
          return {
            ...player,
            digimons: player.digimons.map((d) => ({
              ...d,
              hasActedThisTurn: false,
            })),
          };
        }
        return player;
      }),
    };

    saveGameState(updatedState);
    enqueueSnackbar(
      `Turno de ${capitalize(gameState.players[nextPlayerIndex].name)}!`,
      { variant: "info" }
    );
  };

  const handleDigimonClick = (
    digimon: GameDigimon,
    playerName: string,
    playerId: number
  ) => {
    // Se o Digimon est√° morto, abrir dialog de reviver
    if (digimon.currentHp <= 0) {
      setReviveTarget({ digimon, name: digimon.name, playerId });
      setShowReviveDialog(true);
    } else {
      setSelectedDigimon({
        digimon,
        playerName,
        playerId,
        originalId: digimon.originalId || digimon.id, // Usar originalId se existir
      });
    }
  };

  const applyDamageToDigimon = (digimon: GameDigimon, damageAmount: number) => {
    if (!gameState)
      return { newHp: digimon.currentHp, evolutionUnlocked: false };

    let evolutionUnlocked = false;

    // Calcular nova HP
    const newHp = Math.max(0, digimon.currentHp - damageAmount);

    // Calcular % de vida perdida TOTAL (n√£o apenas deste dano)
    const hpLostPercentage = ((digimon.dp - newHp) / digimon.dp) * 100;

    // Chance base de 20% + 5% a cada 10% de vida perdida
    const evolutionChance = 20 + Math.floor(hpLostPercentage / 10) * 5;

    // Rolar D100 para verificar evolu√ß√£o (apenas se ainda n√£o pode evoluir)
    if (!digimon.canEvolve && newHp > 0) {
      const roll = Math.floor(Math.random() * 100) + 1;
      if (roll <= evolutionChance) {
        evolutionUnlocked = true;
        enqueueSnackbar(
          `üåü EVOLU√á√ÉO LIBERADA! ${capitalize(
            digimon.name
          )} pode evoluir! (Rolou ${roll}/${evolutionChance})`,
          { variant: "success" }
        );
      }
    }

    return { newHp, evolutionUnlocked };
  };

  const handleAttackConfirm = (
    targetDigimon: GameDigimon,
    attackerDamage: number,
    defenderDamage: number
  ) => {
    console.log("üì• [handleAttackConfirm] IN√çCIO - Recebendo dados:", {
      targetDigimon: {
        id: targetDigimon.id,
        nome: targetDigimon.name,
        hp: targetDigimon.currentHp,
      },
      attackerDamage,
      defenderDamage,
      gameStateExists: !!gameState,
      attackerDigimonExists: !!attackerDigimon,
      attackContextExists: !!attackContext,
    });

    // Usar attackContext como fallback se selectedDigimon n√£o existir
    const contextToUse =
      attackContext?.originalSelectedDigimon || selectedDigimon;

    // Verifica√ß√£o DETALHADA de cada vari√°vel
    console.log("üîç [handleAttackConfirm] Verifica√ß√£o detalhada:", {
      gameState: gameState ? "OK" : "NULL/UNDEFINED",
      attackerDigimon: attackerDigimon
        ? {
            id: attackerDigimon.digimon?.id,
            nome: attackerDigimon.digimon?.name,
            playerName: attackerDigimon.playerName,
          }
        : "NULL/UNDEFINED",
      attackContext: attackContext
        ? {
            attacker: attackContext.attacker.name,
            playerName: attackContext.attackerPlayerName,
            playerId: attackContext.attackerPlayerId,
          }
        : "NULL/UNDEFINED",
      contextToUse: contextToUse ? "OK" : "NULL/UNDEFINED",
    });

    if (!gameState || !attackerDigimon || !contextToUse) {
      console.error("‚ùå [handleAttackConfirm] Faltam dados necess√°rios!", {
        faltaGameState: !gameState,
        faltaAttackerDigimon: !attackerDigimon,
        faltaContext: !contextToUse,
      });
      return;
    }

    console.log("‚úÖ [handleAttackConfirm] Valida√ß√£o passou, continuando...");

    // Buscar os Digimons atuais do gameState (dados frescos!)
    console.log(
      "üîç [handleAttackConfirm] Buscando Digimons atuais no gameState..."
    );
    let currentTargetDigimon: GameDigimon | null = null;
    let currentAttackerDigimon: GameDigimon | null = null;

    for (const player of gameState.players) {
      for (const digimon of player.digimons) {
        if (digimon.id === targetDigimon.id) {
          currentTargetDigimon = digimon;
          console.log("‚úÖ [handleAttackConfirm] Defensor encontrado:", {
            id: digimon.id,
            nome: digimon.name,
            hp: digimon.currentHp,
            dp: digimon.dp,
          });
        }
        if (digimon.id === attackerDigimon.digimon.id) {
          currentAttackerDigimon = digimon;
          console.log("‚úÖ [handleAttackConfirm] Atacante encontrado:", {
            id: digimon.id,
            nome: digimon.name,
            hp: digimon.currentHp,
            dp: digimon.dp,
          });
        }
      }
    }

    if (!currentTargetDigimon || !currentAttackerDigimon) {
      console.error(
        "‚ùå [handleAttackConfirm] Digimons n√£o encontrados no estado atual!",
        {
          targetId: targetDigimon.id,
          attackerId: attackerDigimon.digimon.id,
          foundTarget: !!currentTargetDigimon,
          foundAttacker: !!currentAttackerDigimon,
        }
      );
      return;
    }

    // Aplicar dano ao defensor (usando dados atuais!)
    console.log("üí• [handleAttackConfirm] Aplicando dano ao defensor...");
    const defenderResult = applyDamageToDigimon(
      currentTargetDigimon,
      attackerDamage
    );
    console.log("üìä [handleAttackConfirm] Resultado defensor:", {
      hpAntes: currentTargetDigimon.currentHp,
      danoRecebido: attackerDamage,
      hpDepois: defenderResult.newHp,
      evoluiuUnlocked: defenderResult.evolutionUnlocked,
    });

    // Aplicar dano ao atacante (usando dados atuais!)
    console.log(
      "üí• [handleAttackConfirm] Aplicando dano ao atacante (contra-ataque)..."
    );
    const attackerResult = applyDamageToDigimon(
      currentAttackerDigimon,
      defenderDamage
    );
    console.log("üìä [handleAttackConfirm] Resultado atacante:", {
      hpAntes: currentAttackerDigimon.currentHp,
      danoRecebido: defenderDamage,
      hpDepois: attackerResult.newHp,
      evolucaoUnlocked: attackerResult.evolutionUnlocked,
    });

    // Atualizar o gameState com os danos aplicados E marcar como j√° agiu
    const updatedState = {
      ...gameState,
      players: gameState.players.map((player) => ({
        ...player,
        digimons: player.digimons.map((d) => {
          // Atualizar defensor
          if (d.id === currentTargetDigimon.id) {
            return {
              ...d,
              currentHp: defenderResult.newHp,
              canEvolve: defenderResult.evolutionUnlocked
                ? true
                : d.canEvolve || false,
            };
          }
          // Atualizar atacante E marcar como j√° agiu
          if (d.id === currentAttackerDigimon.id) {
            return {
              ...d,
              currentHp: attackerResult.newHp,
              canEvolve: attackerResult.evolutionUnlocked
                ? true
                : d.canEvolve || false,
              hasActedThisTurn: true, // Marcar como j√° agiu AQUI
            };
          }
          return d;
        }),
      })),
    };

    console.log("üíæ [handleAttackConfirm] Salvando estado atualizado...");
    saveGameState(updatedState);
    console.log("‚úÖ [handleAttackConfirm] Estado salvo com sucesso!");

    // Debug: Verificar o que foi salvo
    console.log("üîç [handleAttackConfirm] Verificando estado salvo:", {
      atacante: {
        id: currentAttackerDigimon.id,
        nome: currentAttackerDigimon.name,
        hpAntes: currentAttackerDigimon.currentHp,
        hpDepois: attackerResult.newHp,
        agiu: true,
      },
      defensor: {
        id: currentTargetDigimon.id,
        nome: currentTargetDigimon.name,
        hpAntes: currentTargetDigimon.currentHp,
        hpDepois: defenderResult.newHp,
      },
    });

    // Verificar localStorage
    try {
      const savedState = localStorage.getItem("digimon_board_clash_game_state");
      if (savedState) {
        const parsed = JSON.parse(savedState) as GameState;
        const savedAttacker = parsed.players
          .flatMap((p) => p.digimons)
          .find((d) => d.id === currentAttackerDigimon.id);
        const savedDefender = parsed.players
          .flatMap((p) => p.digimons)
          .find((d) => d.id === currentTargetDigimon.id);

        console.log("üîç [handleAttackConfirm] Verifica√ß√£o no localStorage:", {
          atacanteNoLS: savedAttacker
            ? {
                id: savedAttacker.id,
                hp: savedAttacker.currentHp,
                agiu: savedAttacker.hasActedThisTurn,
              }
            : "N√ÉO ENCONTRADO",
          defensorNoLS: savedDefender
            ? { id: savedDefender.id, hp: savedDefender.currentHp }
            : "N√ÉO ENCONTRADO",
        });
      }
    } catch (error) {
      console.error(
        "‚ùå [handleAttackConfirm] Erro ao verificar localStorage:",
        error
      );
    }

    // Mensagens de feedback
    enqueueSnackbar(
      `‚öîÔ∏è ${capitalize(
        attackerDigimon.digimon.name
      )} causou ${attackerDamage.toLocaleString()} de dano em ${capitalize(
        targetDigimon.name
      )}!`,
      { variant: "warning" }
    );

    enqueueSnackbar(
      `üõ°Ô∏è ${capitalize(
        targetDigimon.name
      )} contra-atacou causando ${defenderDamage.toLocaleString()} de dano!`,
      { variant: "info" }
    );

    // N√£o fechar o modal automaticamente - deixar usu√°rio ver os resultados
  };

  const handleEvolve = async (digimon: GameDigimon) => {
    if (!gameState || !digimon.canEvolve) return;

    try {
      // Buscar evolu√ß√£o do Digimon
      const response = await fetch("/api/digimons/evolve", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ digimonId: digimon.id }),
      });

      if (!response.ok) {
        const error = await response.json();
        enqueueSnackbar(error.error || "Erro ao evoluir Digimon", {
          variant: "error",
        });
        return;
      }

      const data = await response.json();
      const evolution = data.evolution;

      // Encontrar o jogador dono do Digimon
      const ownerPlayer = gameState.players.find((p) =>
        p.digimons.some((d) => d.id === digimon.id)
      );

      // Adicionar pontua√ß√£o ao Tamer (se n√£o for n√≠vel 3)
      if (ownerPlayer && evolution.level !== 3) {
        updateTamerScore(ownerPlayer.id, evolution.dp);
      }

      // Atualizar o Digimon no gameState
      const updatedState = {
        ...gameState,
        players: gameState.players.map((player) => ({
          ...player,
          digimons: player.digimons.map((d) => {
            if (d.id === digimon.id) {
              return {
                ...d,
                id: evolution.id,
                name: evolution.name,
                image: evolution.image,
                level: evolution.level,
                dp: evolution.dp,
                typeId: evolution.typeId,
                currentHp: evolution.dp, // HP resetado para 100%
                canEvolve: false, // Reset da flag de evolu√ß√£o
                originalId: d.originalId || digimon.id, // Guardar ID original
              };
            }
            return d;
          }),
        })),
      };

      saveGameState(updatedState);

      const evolutionType = data.wasInEvolutionLine
        ? "linha evolutiva"
        : "evolu√ß√£o aleat√≥ria";

      const scoreMessage =
        evolution.level !== 3 ? ` +${evolution.dp.toLocaleString()} pts!` : "";

      enqueueSnackbar(
        `üéâ ${capitalize(digimon.name)} evoluiu para ${capitalize(
          evolution.name
        )}! (${evolutionType})${scoreMessage}`,
        { variant: "success" }
      );

      // N√£o fecha o modal - mant√©m aberto com dados atualizados
      // O modal j√° atualiza automaticamente pois busca do gameState
    } catch (error) {
      console.error("Erro ao evoluir:", error);
      enqueueSnackbar("Erro ao processar evolu√ß√£o", { variant: "error" });
    }
  };

  const updateTamerScore = (tamerId: number, points: number) => {
    try {
      const stored = localStorage.getItem("digimon_tamer_scores");
      const scores = stored ? JSON.parse(stored) : {};

      scores[tamerId] = (scores[tamerId] || 0) + points;

      localStorage.setItem("digimon_tamer_scores", JSON.stringify(scores));
      console.log(
        `‚≠ê Pontua√ß√£o atualizada - Tamer ${tamerId}: +${points} pts (Total: ${scores[tamerId]})`
      );
    } catch (error) {
      console.error("Erro ao atualizar pontua√ß√£o:", error);
    }
  };

  const handleRevive = (success: boolean) => {
    if (!gameState || !reviveTarget) return;

    if (success) {
      // Reviver com HP cheio
      const updatedState = {
        ...gameState,
        players: gameState.players.map((player) => ({
          ...player,
          digimons: player.digimons.map((d) => {
            if (d.id === reviveTarget.digimon.id) {
              return { ...d, currentHp: d.dp, canEvolve: false };
            }
            return d;
          }),
        })),
      };

      saveGameState(updatedState);
    }

    setReviveTarget(null);
  };

  const markDigimonAsActed = (digimonId: number, playerId: number) => {
    if (!gameState) return;

    const updatedState = {
      ...gameState,
      players: gameState.players.map((player) => {
        if (player.id === playerId) {
          return {
            ...player,
            digimons: player.digimons.map((d) => {
              if ((d.originalId || d.id) === digimonId) {
                return { ...d, hasActedThisTurn: true };
              }
              return d;
            }),
          };
        }
        return player;
      }),
    };

    saveGameState(updatedState);
  };

  const handleLoot = (digimon: GameDigimon) => {
    if (!gameState || !selectedDigimon) return;

    // Rolar D20 para determinar o loot
    const roll = Math.floor(Math.random() * 20) + 1;
    const lootAmount = roll * 100; // Cada ponto = 100 de DP adicional

    enqueueSnackbar(
      `${capitalize(
        digimon.name
      )} saqueou e encontrou ${lootAmount} DP! (D20: ${roll})`,
      { variant: "success" }
    );

    // Marcar como j√° agiu
    markDigimonAsActed(selectedDigimon.originalId, selectedDigimon.playerId);
  };

  const handleRest = (digimon: GameDigimon) => {
    if (!gameState || !selectedDigimon) return;

    // Recuperar 20% do HP m√°ximo (DP)
    const healAmount = Math.floor(digimon.dp * 0.2); // 20% do HP m√°ximo
    const newHp = Math.min(digimon.dp, digimon.currentHp + healAmount);
    const actualHeal = newHp - digimon.currentHp;

    const updatedState = {
      ...gameState,
      players: gameState.players.map((player) => {
        if (player.id === selectedDigimon.playerId) {
          return {
            ...player,
            digimons: player.digimons.map((d) => {
              if ((d.originalId || d.id) === selectedDigimon.originalId) {
                return {
                  ...d,
                  currentHp: newHp,
                  hasActedThisTurn: true,
                };
              }
              return d;
            }),
          };
        }
        return player;
      }),
    };

    saveGameState(updatedState);

    const hpPercentage = Math.round((actualHeal / digimon.dp) * 100);
    enqueueSnackbar(
      `${capitalize(
        digimon.name
      )} descansou e recuperou ${actualHeal.toLocaleString()} HP (${hpPercentage}%)!`,
      { variant: "success" }
    );
  };

  const handleAttack = (digimon: GameDigimon) => {
    if (!gameState || !selectedDigimon) return;

    console.log("üéØ [handleAttack] Salvando contexto do ataque:", {
      attacker: digimon.name,
      selectedDigimon: selectedDigimon.digimon?.name,
      playerId: selectedDigimon.playerId,
    });

    // N√ÉO marcar como agiu ainda - s√≥ ap√≥s confirmar o ataque
    // markDigimonAsActed(selectedDigimon.originalId, selectedDigimon.playerId);

    // Salvar contexto completo do ataque (backup)
    setAttackContext({
      attacker: digimon,
      attackerPlayerName: selectedDigimon.playerName,
      attackerPlayerId: selectedDigimon.playerId,
      originalSelectedDigimon: selectedDigimon,
    });

    // Abrir dialog de ataque para selecionar alvo
    setAttackerDigimon({
      digimon,
      playerName: selectedDigimon.playerName,
    });
    setShowAttackDialog(true);
  };

  const handleCloseAttackDialog = () => {
    console.log("üö™ [handleCloseAttackDialog] Fechando modal de ataque");
    setShowAttackDialog(false);
    // Limpar ap√≥s um pequeno delay para evitar race condition
    setTimeout(() => {
      setAttackerDigimon(null);
      setSelectedDigimon(null);
      setAttackContext(null); // Limpar contexto de ataque tamb√©m
      console.log("üßπ [handleCloseAttackDialog] Estado limpo");
    }, 100);
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gradient-to-b from-gray-900 to-gray-800 flex items-center justify-center">
        <div className="text-center">
          <div className="text-6xl mb-4">‚è≥</div>
          <h3 className="text-xl font-semibold text-gray-300 mb-2">
            Carregando jogo...
          </h3>
        </div>
      </div>
    );
  }

  if (!gameState) {
    return null; // Redireciona no useEffect
  }

  // Tela de Vit√≥ria
  if (winner) {
    return (
      <div className="min-h-screen bg-gradient-to-b from-gray-900 via-purple-900 to-gray-900 flex items-center justify-center p-4">
        <div className="max-w-4xl w-full text-center">
          {/* Anima√ß√£o de fogos */}
          <div className="text-8xl mb-8 animate-bounce">üéâ üèÜ üéâ</div>

          {/* T√≠tulo de Vit√≥ria */}
          <h1 className="text-6xl font-bold text-yellow-400 mb-4 drop-shadow-[0_0_30px_rgba(250,204,21,0.5)]">
            VIT√ìRIA!
          </h1>

          {/* Imagem e Nome do Vencedor */}
          <div className="bg-gradient-to-br from-yellow-500/20 to-purple-500/20 rounded-2xl p-8 mb-8 border-4 border-yellow-500 shadow-2xl">
            <div className="flex flex-col items-center gap-6">
              <div className="w-32 h-32 rounded-full overflow-hidden border-4 border-yellow-400 shadow-lg">
                <img
                  src={winner.playerImage}
                  alt={winner.playerName}
                  className="w-full h-full object-contain"
                  onError={(e) => {
                    const target = e.target as HTMLImageElement;
                    target.style.display = "none";
                    const parent = target.parentElement;
                    if (parent) {
                      parent.innerHTML = `<div class="w-full h-full flex items-center justify-center text-6xl bg-gray-700">üë§</div>`;
                    }
                  }}
                />
              </div>
              <div>
                <p className="text-2xl text-gray-300 mb-2">Vencedor:</p>
                <h2 className="text-5xl font-bold text-white">
                  {capitalize(winner.playerName)}
                </h2>
              </div>
            </div>
          </div>

          {/* Digimons Sobreviventes */}
          <div className="bg-gray-800 rounded-xl p-6 mb-8 border-2 border-purple-500">
            <h3 className="text-2xl font-bold text-purple-400 mb-4">
              ‚öîÔ∏è Digimons Sobreviventes
            </h3>
            <div className="flex flex-wrap items-center gap-4 justify-around">
              {winner.aliveDigimons.map((digimon) => (
                <div
                  key={digimon.id}
                  className="bg-gray-700 rounded-lg p-4 border-2 border-green-500 w-[180px] flex-shrink-0"
                >
                  <div className="relative h-32 bg-gradient-to-br from-gray-600 to-gray-800 rounded-lg overflow-hidden mb-2">
                    {digimon.image ? (
                      <img
                        src={digimon.image}
                        alt={digimon.name}
                        className="w-full h-full object-contain"
                      />
                    ) : (
                      <div className="w-full h-full flex items-center justify-center text-4xl">
                        ‚ùì
                      </div>
                    )}
                  </div>
                  <p className="text-white font-bold text-center">
                    {capitalize(digimon.name)}
                  </p>
                  <p className="text-green-400 text-sm text-center">
                    HP: {digimon.currentHp.toLocaleString()} /{" "}
                    {digimon.dp.toLocaleString()}
                  </p>
                  <p className="text-purple-400 text-xs text-center">
                    {getLevelName(digimon.level)}
                  </p>
                </div>
              ))}
            </div>
          </div>

          {/* Estat√≠sticas */}
          <div className="bg-gray-800 rounded-xl p-6 mb-8 border-2 border-blue-500">
            <h3 className="text-xl font-bold text-blue-400 mb-4">
              üìä Estat√≠sticas da Partida
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
              <div>
                <p className="text-gray-400 text-sm">Total de Turnos</p>
                <p className="text-3xl font-bold text-white">
                  {gameState.turnCount}
                </p>
              </div>
              <div>
                <p className="text-gray-400 text-sm">Digimons Sobreviventes</p>
                <p className="text-3xl font-bold text-green-400">
                  {winner.aliveDigimons.length}
                </p>
              </div>
              <div>
                <p className="text-gray-400 text-sm">Jogadores</p>
                <p className="text-3xl font-bold text-purple-400">
                  {gameState.players.length}
                </p>
              </div>
            </div>
          </div>

          {/* Bot√£o para voltar */}
          <button
            onClick={handleEndGame}
            className="px-12 py-4 bg-gradient-to-r from-blue-600 to-purple-600 text-white text-xl font-bold rounded-lg hover:from-blue-700 hover:to-purple-700 transition-all transform hover:scale-105 shadow-2xl"
          >
            üè† Voltar para P√°gina Inicial
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-b from-gray-900 to-gray-800">
      {/* Header */}
      <header className="bg-gray-800 shadow-md border-b border-gray-700">
        <div className="container mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold text-blue-400">
                Digimon Board Clash
              </h1>
              <p className="text-xs text-gray-400 mt-1">
                Jogo iniciado em{" "}
                {new Date(gameState.createdAt).toLocaleString("pt-BR")}
              </p>
            </div>

            <div className="flex items-center gap-4">
              {/* Contador de Turnos */}
              <div className="bg-gray-700 px-4 py-2 rounded-lg border border-gray-600">
                <p className="text-xs text-gray-400">Turno</p>
                <p className="text-xl font-bold text-purple-400">
                  #{gameState.turnCount}
                </p>
              </div>

              {/* Bot√£o Passar Turno */}
              <button
                onClick={handleNextTurn}
                className="px-6 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition-colors flex items-center gap-2"
              >
                <span>‚è≠Ô∏è</span>
                <span>Passar Turno</span>
              </button>

              {/* Bot√£o Finalizar Jogo */}
              <button
                onClick={() => setShowEndGameConfirm(true)}
                className="px-6 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition-colors"
              >
                üö™ Finalizar Jogo
              </button>
            </div>
          </div>
        </div>
      </header>

      {/* Conte√∫do Principal */}
      <main className="container mx-auto px-6 py-8">
        <div className="mb-8">
          <h2 className="text-4xl font-bold text-white mb-2">
            üéÆ Jogo em Andamento
          </h2>
          <p className="text-gray-300">
            {gameState.players.length} jogador
            {gameState.players.length > 1 ? "es" : ""} participando
          </p>
        </div>

        <div className="card">
          <h3 className="text-2xl font-bold text-white mb-2">
            üéÆ Jogo em Andamento
          </h3>
          <p className="text-gray-300">
            {gameState.players.length} jogador
            {gameState.players.length > 1 ? "es" : ""} participando
          </p>
        </div>

        {/* Lista de Jogadores com seus Digimons */}
        <div className="space-y-6">
          {gameState.players.map((player, playerIndex) => {
            const isCurrentTurn =
              playerIndex === gameState.currentTurnPlayerIndex;

            return (
              <div
                key={player.id}
                className={`bg-gray-800 rounded-lg shadow-lg p-6 border-2 transition-all ${
                  isCurrentTurn
                    ? "border-yellow-500 ring-4 ring-yellow-500/30 shadow-yellow-500/50"
                    : "border-gray-700"
                }`}
              >
                {/* Informa√ß√µes do Jogador */}
                <div className="flex items-center gap-4 mb-6 pb-4 border-b border-gray-700">
                  <div className="w-16 h-16 flex-shrink-0 rounded-full overflow-hidden bg-gray-700 border-2 border-gray-600">
                    <img
                      src={getTamerImagePath(player.avatar)}
                      alt={player.name}
                      className="w-full h-full object-contain"
                      onError={(e) => {
                        // Fallback para emoji se a imagem n√£o existir
                        const target = e.target as HTMLImageElement;
                        target.style.display = "none";
                        const parent = target.parentElement;
                        if (parent) {
                          parent.innerHTML = `<div class="w-full h-full flex items-center justify-center text-4xl">üë§</div>`;
                        }
                      }}
                    />
                  </div>
                  <div className="flex-1">
                    <div className="text-xs text-gray-400 font-semibold mb-1">
                      Jogador {playerIndex + 1}
                    </div>
                    <h3 className="text-2xl font-bold text-white flex items-center gap-2">
                      {capitalize(player.name)}
                      {isCurrentTurn && (
                        <span className="text-yellow-400 text-lg animate-pulse">
                          ‚≠ê
                        </span>
                      )}
                    </h3>
                    {isCurrentTurn && (
                      <p className="text-yellow-400 font-bold text-sm mt-1">
                        üéØ Turno Atual
                      </p>
                    )}
                  </div>
                  <div className="text-right">
                    <div className="text-xs text-gray-400 mb-1">Parceiros</div>
                    <div className="text-2xl font-bold text-blue-400">
                      {player.digimons.length}
                    </div>
                  </div>
                </div>

                {/* Digimons do Jogador */}

                <div>
                  <h4 className="text-sm font-semibold text-gray-300 mb-3 uppercase tracking-wide">
                    üé¥ Digimons Parceiros
                  </h4>

                  <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    {player.digimons.map((digimon) => {
                      const isDead = digimon.currentHp <= 0;
                      const cardContent = (
                        <div
                          onClick={() =>
                            handleDigimonClick(digimon, player.name, player.id)
                          }
                          className={`bg-gray-700 rounded-lg overflow-hidden border transition-all group cursor-pointer transform hover:scale-105 ${
                            isDead
                              ? "border-gray-800 hover:border-yellow-500"
                              : digimon.canEvolve
                              ? "border-gray-600 hover:border-blue-400"
                              : "border-gray-600 hover:border-blue-400"
                          } ${digimon.canEvolve && !isDead ? "rainbow-border" : ""}`}
                        >
                          {/* Layout Horizontal: Imagem √† esquerda, dados √† direita */}
                          <div className="flex h-40">
                            {/* Imagem do Digimon - Lado Esquerdo */}
                            <div className="relative w-40 h-40 bg-gradient-to-br from-gray-600 to-gray-800 overflow-hidden flex-shrink-0">
                              {isDead && (
                                <div className="absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center z-10">
                                  <div className="text-center">
                                    <div className="text-3xl mb-1">üíÄ</div>
                                    <p className="text-red-400 font-bold text-xs">
                                      MORTO
                                    </p>
                                  </div>
                                </div>
                              )}
                              {digimon.image ? (
                                <img
                                  src={digimon.image}
                                  alt={digimon.name}
                                  className="w-full h-full object-contain group-hover:scale-110 transition-transform duration-300"
                                  style={
                                    isDead
                                      ? {
                                          filter:
                                            "grayscale(100%) brightness(0.7)",
                                        }
                                      : undefined
                                  }
                                />
                              ) : (
                                <div className="w-full h-full flex items-center justify-center text-4xl">
                                  ‚ùì
                                </div>
                              )}
                              {/* Badge de Level */}
                              <div className="absolute top-1 left-1 bg-blue-600 text-white text-xs font-bold px-1 py-0.5 rounded">
                                {getLevelName(digimon.level)}
                              </div>
                              {/* Badge de Evolu√ß√£o Liberada */}
                              {digimon.canEvolve && !isDead && (
                                <div className="absolute bottom-1 left-1/2 transform -translate-x-1/2 bg-gradient-to-r from-yellow-500 to-orange-500 text-white text-xs font-bold px-2 py-0.5 rounded-full animate-pulse shadow-lg">
                                  ‚ú®
                                </div>
                              )}
                              {/* Badge de J√° Agiu no Turno */}
                              {digimon.hasActedThisTurn &&
                                !isDead &&
                                playerIndex ===
                                  gameState.currentTurnPlayerIndex && (
                                  <div className="absolute top-1 right-1 bg-gray-700 text-white text-xs font-bold px-1 py-0.5 rounded shadow-lg border border-gray-500">
                                    ‚è∏Ô∏è
                                  </div>
                                )}
                            </div>

                            {/* Dados do Digimon - Lado Direito */}
                            <div className="flex-1 p-3 flex flex-col justify-between">
                              {/* Nome, Tipo e DP */}
                              <div>
                                <h5 className="font-bold text-white text-sm mb-1">
                                  {capitalize(digimon.name)}
                                </h5>
                                <div className="flex gap-2 items-center mb-1">
                                  <div className="bg-blue-600 text-white text-xs font-bold px-2 py-1 rounded">
                                    {
                                      DIGIMON_TYPE_NAMES[
                                        digimon.typeId as keyof typeof DIGIMON_TYPE_NAMES
                                      ]
                                    }
                                  </div>
                                  <div className="bg-purple-600 text-white text-xs font-bold px-2 py-1 rounded">
                                    {digimon.dp.toLocaleString()} DP
                                  </div>
                                </div>
                              </div>

                              {/* Barra de Vida (HP) */}
                              <div className="space-y-1">
                                <div className="flex justify-between items-center text-xs">
                                  <span className="text-gray-400 font-semibold">
                                    HP
                                  </span>
                                  <span className="text-green-400 font-bold">
                                    {Math.max(
                                      0,
                                      digimon.currentHp
                                    ).toLocaleString()}{" "}
                                    / {digimon.dp.toLocaleString()}
                                  </span>
                                </div>
                                <div className="w-full bg-gray-600 rounded-full h-3 overflow-hidden border border-gray-500 shadow-inner">
                                  <div
                                    className="h-full bg-gradient-to-r from-green-500 to-green-400 transition-all duration-300 ease-out flex items-center justify-center"
                                    style={{
                                      width: `${Math.max(
                                        0,
                                        (digimon.currentHp / digimon.dp) * 100
                                      )}%`,
                                    }}
                                  >
                                    {Math.max(0, digimon.currentHp) /
                                      digimon.dp >=
                                      0.25 && (
                                      <span className="text-xs font-extrabold text-white drop-shadow-[0_2px_4px_rgba(0,0,0,0.8)]">
                                        {Math.round(
                                          Math.max(
                                            0,
                                            (digimon.currentHp / digimon.dp) *
                                              100
                                          )
                                        )}
                                        %
                                      </span>
                                    )}
                                  </div>
                                </div>
                              </div>
                            </div>
                        </div>
                      );

                      return cardContent;
                    })}
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </main>

      {/* Modal de Confirma√ß√£o para Finalizar Jogo */}
      {showEndGameConfirm && (
        <div
          className="fixed inset-0 bg-black bg-opacity-20 backdrop-blur-md flex items-center justify-center z-50 p-4"
          onClick={() => setShowEndGameConfirm(false)}
        >
          <div
            className="bg-gray-800 rounded-lg shadow-xl max-w-md w-full border border-gray-700"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="bg-red-600 text-white px-6 py-4 rounded-t-lg">
              <h3 className="text-xl font-bold">‚ö†Ô∏è Finalizar Jogo</h3>
            </div>
            <div className="p-6">
              <p className="text-gray-200 mb-2">
                Tem certeza que deseja finalizar o jogo?
              </p>
              <p className="text-gray-400 text-sm">
                Todo o progresso ser√° perdido e voc√™ ser√° redirecionado para a
                tela inicial.
              </p>
            </div>
            <div className="bg-gray-900 px-6 py-4 rounded-b-lg flex justify-end gap-3 border-t border-gray-700">
              <button
                onClick={() => setShowEndGameConfirm(false)}
                className="px-6 py-2 bg-gray-700 text-white font-semibold rounded-lg hover:bg-gray-600 transition-colors"
              >
                Cancelar
              </button>
              <button
                onClick={handleEndGame}
                className="px-6 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition-colors"
              >
                Finalizar
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Modal de Detalhes do Digimon */}
      <DigimonDetailsModal
        isOpen={selectedDigimon !== null && !showAttackDialog}
        onClose={() => {
          // S√≥ fechar se n√£o estiver em um ataque
          if (!showAttackDialog) {
            setSelectedDigimon(null);
          }
        }}
        digimon={
          selectedDigimon
            ? // Buscar dados atualizados do gameState usando originalId
              gameState?.players
                .find((p) => p.id === selectedDigimon.playerId)
                ?.digimons.find(
                  (d) =>
                    (d.originalId || d.id) === selectedDigimon.originalId ||
                    d.id === selectedDigimon.digimon.id
                ) || null
            : null
        }
        playerName={selectedDigimon?.playerName || ""}
        onEvolve={handleEvolve}
        onLoot={handleLoot}
        onRest={handleRest}
        onAttack={handleAttack}
        isCurrentPlayerTurn={
          selectedDigimon !== null &&
          gameState !== null &&
          gameState.players.findIndex(
            (p) => p.id === selectedDigimon.playerId
          ) === gameState.currentTurnPlayerIndex
        }
      />

      {/* Dialog de Ataque */}
      <AttackDialog
        isOpen={showAttackDialog}
        onClose={handleCloseAttackDialog}
        onConfirm={handleAttackConfirm}
        onEvolve={handleEvolve}
        attacker={attackerDigimon}
        players={gameState?.players || []}
        currentPlayerId={
          gameState?.players[gameState.currentTurnPlayerIndex]?.id || 0
        }
      />

      {/* Dialog de Reviver */}
      <ReviveDialog
        isOpen={showReviveDialog}
        onClose={() => {
          setShowReviveDialog(false);
          setReviveTarget(null);
        }}
        onRevive={handleRevive}
        digimonName={capitalize(reviveTarget?.name || "")}
      />
    </div>
  );
}
